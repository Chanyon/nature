import runtime_temp

type coroutine_t<T> = cptr

type future_t<T> = struct{
    coroutine_t<T> co
    T result
}

type chan_t<T> = struct{
}

fn co_async<T>(fn() function, int flag):future_t<T> {
    int result_size = @sizeof(T)

    var co = rt_coroutine_async(function as cptr, flag, result_size) as coroutine_t<T>

    return future_t<T>{
        co = co
    }
}

fn co_return<T>(ptr<T> result) {
    // println("co_return", *result)
    rt_coroutine_return(result as cptr)
}

fn future_t<T>.await():T {
    // register wait result loop and yield
    rt_coroutine_yield()

    // rt_coroutine_result(&self.result)
    return self.result
}
