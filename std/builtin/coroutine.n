import runtime_temp

type future_t<T> = struct{
    i64 size
    raw_ptr<T> result
    void_ptr await_co
}

type chan_t<T> = struct{
}

fn co_async<T>(fn() function, int flag):ptr<future_t<T>> {
    var fu = new future_t<T>
    fu.size = @sizeof(T)
    if fu.size > 0 {
        var hash = @reflect_hash(T)
        fu.result = gc_malloc(hash) as raw_ptr<T>
    }

    void_ptr await_co = rt_coroutine_async(function as void_ptr, flag, fu as void_ptr)

    fu.await_co = await_co
    return fu
}

fn co_return<T>(raw_ptr<T> result) {
    rt_coroutine_return(result as void_ptr)
}

fn future_t<T>.await():T {
    rt_coroutine_await(self.await_co)

    var err = rt_coroutine_error(self.await_co)
    if !(err is null) {
        let err as ptr<error_t>

        throw err.msg
    }

    return *(self.result as ptr<T>)
}
