import runtime_temp

type future_t<T> = struct{
    i64 size
    nptr<T> result
    cptr await_co
}

type chan_t<T> = struct{
}

fn co_async<T>(fn() function, int flag):future_t<T> {
    var future = future_t<T>{
        result = null,
        size = @sizeof(T)
    }

    if future.size > 0 {
        var hash = @reflect_hash(T)
        future.result = gc_malloc(hash) as ptr<T>
    }

    cptr await_co = rt_coroutine_async(function as cptr, flag, future as cptr)

    future.await_co = await_co
    return future
}

fn co_return<T>(ptr<T> result) {
    // println("co_return", *result)
    rt_coroutine_return(result as cptr)
}

fn future_t<T>.await():T {
    rt_coroutine_await(self.await_co)

    var err = rt_coroutine_error(self.await_co)
    if !(err is null) {
        let err as ptr<error_t>

        throw err.msg
    }

    return *self.result
}
