import runtime

// 暂时无法通过 struct 推导
// type vec<T> = struct{
//    anyptr data
//    int len
//    int cap
//    int reflect_hash
//    int ele_reflect_hash
// }

fn vec_new<T>(...[int] args):vec<T> {
    int hash = @reflect_hash(vec<T>)
    int ele_hash = @reflect_hash(T)
    int len = -1
    int cap = -1
    if args.len() == 1 {
        len = args[0]
    } else if args.len() == 2 {
        len = args[0]
        cap = args[1]
    }

    return runtime.vec_new(hash, ele_hash, len, cap) as vec<T>
}

fn vec<T>.push(T v) {
    rawptr<T> ref = &v
    return runtime.vec_push(self as anyptr, ref as anyptr)
}

#linkid rt_vec_append
fn vec<T>.append(vec<T> l2)

fn vec<T>.slice(int start, int end):vec<T> {
    return runtime.vec_slice(self as anyptr, start, end) as vec<T> catch e {
        panic(e.msg())
    }
}

#linkid rt_vec_concat
fn vec<T>.concat(vec<T> l2):vec<T>

#linkid rt_vec_copy
fn vec<T>.copy(vec<T> src):int

#linkid rt_vec_length
fn vec<T>.len():int

#linkid rt_vec_capacity
fn vec<T>.cap():int

#linkid rt_vec_ref
fn vec<T>.ref():anyptr