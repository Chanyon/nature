import runtime

// 暂时无法通过 struct 推导
// type vec<T> = struct{
//    anyptr data
//    int len
//    int cap
//    int reflect_hash
//    int ele_reflect_hash
// }

fn vec_new<T>(...[int] args):vec<T> {
    int hash = @reflect_hash(vec<T>)
    int ele_hash = @reflect_hash(T)
    int len = -1
    int cap = -1
    if args.len() == 1 {
        len = args[0]
    } else if args.len() == 2 {
        len = args[0]
        cap = args[1]
    }

    return runtime.vec_new(hash, ele_hash, len, cap) as vec<T>
}

fn vec<T>.push(T v) {
    rawptr<T> ref = &v
    return runtime.vec_push(self as anyptr, ref as anyptr)
}

#linkid rt_vec_append
fn vec<T>.append(vec<T> l2)

fn vec<T>.slice(int start, int end):vec<T> {
    return runtime.vec_slice(self as anyptr, start, end) as vec<T> catch e {
        panic(e.msg())
    }
}

#linkid rt_vec_concat
fn vec<T>.concat(vec<T> l2):vec<T>

#linkid rt_vec_copy
fn vec<T>.copy(vec<T> src):int

#linkid rt_vec_length
fn vec<T>.len():int

#linkid rt_vec_capacity
fn vec<T>.cap():int

#linkid rt_vec_ref
fn vec<T>.ref():anyptr

fn vec<T>.sort() {
    self.sort_at(fn(int a, int b):bool {
        return self[a] < self[b]
    })
}

fn vec<T>.sort_at(fn(int, int):bool less) {
    self.quick_sort(0, self.len() - 1, less)
}

fn vec<T>.sort_by(fn(T, T):bool cmp) {
    self.sort_at(fn(int a, int b):bool {
        return cmp(self[a], self[b])
    })
}

fn vec<T>.quick_sort(int low, int high, fn(int, int):bool less) {
    if low < high {
        int pivot_index = self.partition(low, high, less)
        self.quick_sort(low, pivot_index - 1, less)
        self.quick_sort(pivot_index + 1, high, less)
    }
}

fn vec<T>.partition(int low, int high, fn(int, int):bool less):int {
    int i = low - 1
    
    for int j = low; j < high; j += 1 {
        if less(j, high) {
            i += 1
            T temp = self[i]
            self[i] = self[j]
            self[j] = temp
        }
    }
    
    T temp = self[i + 1]
    self[i + 1] = self[high]
    self[high] = temp
    
    return i + 1
}