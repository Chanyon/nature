import std
import std.path
import std.elf
import syscall
import parker.log as *
import parker.util
import parker.croup
import compress.tgz
import libc_temp

var version = '0.1.0'

if util.arg_verbose() {
    tgz.verbose = true
    set_verbose()
}

logf('runner start version: %s', version)

// - read exe path
var exe_path = std.exe()
var workdir = path.dir(exe_path)
logf('workdir=%s', workdir)

// - extract tgz by exe
var tgz_buf = util.extract_tgz(exe_path)

// - mount namespace
mount_ns(workdir)

// - write tgz to mount ns
tgz_path = path.join(workdir, 'parker.tag.gz')
var tgz_fd = syscall.open(tgz_path, syscall.O_RDONLY | syscall.O_CREAT, 0644)
var err = try syscall.write(tgz_fd, tgz_buf)
assertf(!err.has, 'write tgz to %s failed, err=%s', tgz_path, err.msg)

// - un tgz file
tgz.decode(workdir, tgz_path)
logf('tgz decode success')

// - read target
var target_path = util.read_target(workdir)
logf('read target_path success', target_apth)

// - cgroup new
var cg = cgroup.make()

// - run target with cgroup
var pid = util.run_target(cg, target_path)

var sigfd = util.sig_notify()

// - listen sig or wait cmd
var sig_info = signalfd_siginfo_t{}
for true {
    var (result, status) = syscall.wait(pid, 1)
    if result != 0 { // pid  is down       
        logf('pid %d is exit status=%d', pid, status)

        // clear cgroup dir
        cg.clear()
        break
    }

    var (len, err) = try syscall.read(sigfd, sig_info as cptr, sizeof(signalfd_siginfo_t))
    // sig to the pid process but no operation is done
    // Resource temporarily unavailable
    if err.has && err.msg != 'Resource temporarily unavailable' {
        assertf(false, 'read sigfd %d err=%s', sigfd, err.msg)
    } else {
        // sync the received sig to the pid
        syscall.kill(pid, sig_info.ssi_signo)
        logf('send sig=%d to pid=%d', sig_info.ssi_signo, pid)
    }

    // sleep 100ms
    usleep(100000);
}

logf('successful and exit')

