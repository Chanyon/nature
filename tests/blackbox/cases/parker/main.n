import std
import std.path
import std.elf
import syscall
import parker.log as * 
import parker.util
import compress.tgz

tgz.verbose = true
set_verbose()

var args = std.args()

// - 读取当前程序所在目录，找到 runner 程序
assertf(args.len() > 1, 'args failed')

// 可能是一个绝对路径也可以是一个相对 path
var exec_path = args[0]
logf('exec_path: %v', exec_path)

var target_name = args[1]

// - 读取当前工作目录, 确定需要打包的目录
var workdir = syscall.getcwd()
logf('workdir: %v, target: %v', workdir, target_name)

var target_path = path.join(workdir, target_name)

// - 检查文件是否存在
assertf(path.exists(target_path), 'file=%v notfound', target_path)
logf('target_path: %v found', target_path)

// - 压缩到工作目录即可, 名字就叫 {target_name}.tar.gz
var tgz_name = std.sprintf('%v.tar.gz', target_name)

// new target_name + 'd' fd, node -> noded
var output_name = std.sprintf('%vd', target_name)


// - 遍历当前工作目录中的所有文件，进行压缩
var sources = std.listdir(workdir)

[string] temp = []

// 跳过, target_name + .tar_gz and target_name + d
for s in sources {
    if {tgz_name, output_name}.has(s) {
        logf('tgz encode source %v will continue', s)
        continue
    }

    temp.push(s)
}
sources = temp

// .target_name 将 target_name 写入到文件 .target_name 中随压缩包一起压缩
var fd = syscall.open('.target_name', syscall.O_RDWR | syscall.O_CREAT, 0755)
syscall.write(fd, target_name as [u8], target_name.len())
syscall.close(fd)

tgz.encode(workdir, tgz_name, sources)

logf('encode to tgz_name %v in %v', tgz_name, workdir)


// 如果存在环境变量 RUNNER_PATH, 则有优先读取环境变量
var runner_dir =  syscall.get_env('RUNNER_DIR')
if runner_dir == '' {
    runner_dir = path.dir(exec_path)
}

// 优先根据 target_path 的类型进行自动选择，默认选择 runner_linux_amd64 进行压缩(可能是一个 shell, 不存在 elf 判断)
// 计算 arch 并拼接出 runner 完整路径
var runner_ident = 'runner_linux_amd64'
var (arch, err) = try elf.arch(target_path)
if err.has {
    logf('elf target err: %v', err.msg)
} else {
    runner_ident = std.sprintf('runner_linux_%v', arch)
}

var runner_path = path.join(runner_dir, runner_ident)

assertf(path.exists(runner_path), 'runner file=%v notfound', runner_path)
logf('runner_path=%v found', runner_path)

// 使用 st size 计算文件的大小
var st = syscall.stat(tgz_name)
var tgz_size = st.size // byte
logf('tgz %v size=%v', tgz_name, tgz_size)

// open and create
var output_fd = syscall.open(output_name, syscall.O_CREAT | syscall.O_RDWR | syscall.O_TRUNC, 0755)

// - append runner
var runner_fd = syscall.open(runner_path, syscall.O_RDONLY, 0666)

var buf = [] as [u8;102400]
var readsum = 0
for true {
    var len = syscall.read(runner_fd, buf)
    readsum += len
    if len == 0 {
        logf('read runner success, len: %v byte', readsum)
        break
    }

    syscall.write(output_fd, buf, len)

    // logf('read item len: %v and write to output file', len)
}
logf('write runner to output success, size=%v', readsum)

// - append tgz

// - append size


